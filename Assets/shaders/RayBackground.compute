// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel RayTracing

#include "RayMarchingLibrary.cginc"
#include "UnityCG.cginc"

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
Texture2D<float4> CumTexture;
Texture2D<float4> BlokTexture;
vector BlokResolution;
//depth texture
Texture2D<float4> CumDepthTexture;

vector Resolution;
vector Frustum[4];

vector CameraPosition;
vector CameraScale;
vector CameraRotation;

//number of objects in a scene
int ObjectsCap;
int NightMode;

vector ShapePosition[100];
vector ShapeRotation[100];
vector ShapeScale[100];

vector SkyboxScale;

//main light:
//unused;
vector LightColor;
vector LightIntensity;
int LightType;
vector LightPosition;
vector LightRotation;


float3 SignedDistanceField(float3 rayOr, float3 rayDir)
{
    float finalDist = 10000;
    //object loop
    for (int i = 0; i < ObjectsCap; i++)
    {
        float3 localPos = rayOr - ShapePosition[i].xyz;
        //resultDist = SingleShape(localPos, ShapeScale[i], ShapeType[i]);
        //float3 resultVect = SphereShapeVector(localPos / ShapeScale[i].xyz);

        //magic function
        //float resultDist = length(resultVect);
        //float resultDist = dot(resultVect, resultVect) / dot(resultVect, rayDir);
        float resultDist = InfiniCubeShape(localPos / ShapeScale[i].xyz);

        //rescale
        //resultDist *= min(ShapeScale[i].x, min(ShapeScale[i].y, ShapeScale[i].z));
        
        //over 90 degrees case
        /*
        if (resultDist < 0)
        {
            CalculateShape[i] = false;
            continue;
        }
        */
        //only adding for now
        finalDist = min(finalDist, resultDist);
    }

    return finalDist;
}

[numthreads(8,8,1)]
void RayTracing (uint3 id : SV_DispatchThreadID)
{
    float2 uv = float2(float(id.x) / Resolution.x, float(id.y) / Resolution.y);
    float3 rayOrg = CameraPosition.xyz;
    float sceneDepth = LinearEyeDepth(CumDepthTexture[id.xy].x);
    //rayOrg.x = 10 * (uv.x - 0.5f);
    //rayOrg.y = 10 * (uv.y -  0.5f);
    //float3 rayDir = float3(0, 0, 1);
    //float fov = 90.0;
    //float3 rayDir = normalize(float3(float2(uv.x - 0.5f, uv.y - 0.5f), -tan(fov / 2.0)));
    //rayDir = Rotate3D(rayDir, -CameraRotation.xyz);
    //float3 rayDir = normalize(ToDirection(float3(uv.x - 0.5f, uv.y - 0.5f, CameraPosition.w)));
    
    //frustum ray dir
    float3 rayDir = ToDirection(float3(uv.x - 0.5f, uv.y - 0.5f, CameraPosition.w));
    if (uv.x >= 0.5f && uv.y >= 0.5f)
    {
        rayDir = normalize(ToDirection(float3(Frustum[2].x * (uv.x - 0.5f) * 2, Frustum[2].y * (uv.y - 0.5f) * 2, Frustum[2].z)));
    }
    else if (uv.x <= 0.5f && uv.y >= 0.5f)
    {
        rayDir = normalize(ToDirection(float3(Frustum[2].x * (uv.x - 0.5f) * 2, Frustum[2].y * (uv.y - 0.5f) * 2, Frustum[2].z)));
    } 
    else if (uv.x <= 0.5f && uv.y <= 0.5f)
    {
        rayDir = normalize(ToDirection(float3(Frustum[2].x * (uv.x - 0.5f) * 2, Frustum[2].y * (uv.y - 0.5f) * 2, Frustum[2].z)));
    }
    else if (uv.x >= 0.5f && uv.y <= 0.5f)
    {
        rayDir = normalize(ToDirection(float3(Frustum[2].x * (uv.x - 0.5f) * 2, Frustum[2].y * (uv.y - 0.5f) * 2, Frustum[2].z)));
    }

    rayDir = Rotate3D(rayDir, CameraRotation.xyz);
    rayDir = normalize(rayDir);

    float4 ResColor = CumTexture[id.xy];
    float3 normals = float3(0, 0, 0);
    float4 Hit = float4(0, 0, 0, 0);

    //if (ResColor.w < 0.1)
    //{
        float3 rayPos = rayOrg;
        ResColor = float4(rayDir.x, rayDir.y, rayDir.z, 1);

        /*
        for (int i = 0; i < 256; i++)
        {
            //float result = SignedDistanceField(rayPos, rayDir);

            if (result < 0.001)
            {
                //hitted
                ResColor = float4(0, 1, 1, 1);
                break;
            }

            //rayPos += rayDir * result;
        }
        */
        bool hitted = false;
        float depthBuffer = 8192;
        for (int i = 0; i < ObjectsCap; i++)
        {
            //if (SimplePlane(rayDir, rayPos - ShapePosition[i].xyz, ShapeScale[i].xyz, Hit, 0))
            bool singleHit = SimpleInfiniCube(ShapePosition[i].xyz - rayPos, Hit, rayDir, ShapeScale[i].xyz / 2, normals);
            float hitDepth = length(Hit);
            if (singleHit && hitDepth < depthBuffer)
            {
                depthBuffer = hitDepth;
                hitted = true;
                //take x or z accordingly
                Hit = float4(Hit.xyz + rayPos, 1);
                if (abs(Hit.x - ShapePosition[i].x) / ShapeScale[i].x < abs(Hit.z - ShapePosition[i].z) / ShapeScale[i].z)
                {
                    Hit = abs(Hit % BlokResolution.z / BlokResolution.z);
                    ResColor = BlokTexture[Hit.xy * BlokResolution.xy];
                }
                else
                {
                    Hit = abs(Hit % BlokResolution.z / BlokResolution.z);
                    ResColor = BlokTexture[Hit.zy * BlokResolution.xy];
                }
            }
            else
            {
                
            }
        }

        if (!hitted)
        {
            //fog
            //get skybox coordinates:
            //SimplePlane();
            //get special giant sphere around camera
            Hit = float4(rayDir * 16, 1);
            //bool unused = SimplePlane(rayDir, float3(0, -100, 0), float3(8192, 8192, 8192), Hit, 0);
            float noise = GradientNoise(float3(Hit.x * SkyboxScale.x, Hit.y * SkyboxScale.y, SkyboxScale.w * SkyboxScale.z * 1.5));
            if (NightMode == 0)
            {
                ResColor = float4(0.5 + noise / 2, 0.5f + noise / 2, 0.5f + noise / 2, 1);
            }
            else
            {
                float noise2 = GradientNoise(float3((Hit.y + 0.1 * SkyboxScale.w) * SkyboxScale.x, (Hit.x + 0.1 * SkyboxScale.w) * SkyboxScale.y, SkyboxScale.w * SkyboxScale.z * 1.5));
                ResColor = float4(noise2 - 0.3f, noise2 - 0.3f, noise * 1.5 - 0.3f, 1);
            }
        }

        //retrieve original image if much more in front of a camera
        //length(Frustum[2])
        if (sceneDepth < depthBuffer)
        {
            ResColor = CumTexture[id.xy];
        }
        //ResColor = depthBuffer / 10;
    //}

    Result[id.xy] = ResColor;
    //float depth = DecodeDepth(CumDepthTexture, uv);  // sample from depth texture
    //depth = Linear01Depth(depth);
    //Result[id.xy] = float4(depth, depth, depth, 1);
    //Result[id.xy] = CumDepthTexture[id.xy] * 4;
}
